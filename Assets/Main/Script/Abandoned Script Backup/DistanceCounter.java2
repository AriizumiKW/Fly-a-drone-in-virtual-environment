using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using OpenCvSharp;

public class DistanceCounter : MonoBehaviour
{
    public const float FOCAL_LENGTH = 20.0f; // millimeters
    public const float BASELINE_LENGTH = 1000.0f; // millimeters
    public const float COEFF = 0; // coefficient
    public InterfaceManager uiManager;
    //public Texture2D templateTexture2DFormat;

    private float timer;
    private Mat leftImg;
    private Mat rightImg;
    private Mat fundMatrix;
    private Mat template;

    // Start is called before the first frame update
    void Awake()
    {
        timer = 0;
        //template = Mat.FromImageData(templateTexture2DFormat.EncodeToPNG()); // convert to OpenCv.Mat data type
        template = Cv2.ImRead(Application.persistentDataPath + "/template.png");
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        if (uiManager.getLock()) // if locked, do nothing
        {
            return;
        }
        // count the distance
        //Point matchPoint = matchingLeftImage();

        timer += Time.deltaTime;
        if(timer >= 1.0f)
        {
            Point matchPoint = matchLeftImage(); // run once per second
            timer = 0;
        }
    }

    private Point matchLeftImage()
    {
        // image matching
        Mat result = new Mat();
        double maxVal;
        double minVal;
        Point minLoc = new Point();
        Point maxLoc = new Point();
        Cv2.MatchTemplate(leftImg, template, result, TemplateMatchModes.SqDiffNormed);
        Cv2.MinMaxLoc(result, out minVal, out maxVal, out minLoc, out maxLoc);
        //Debug.Log(minLoc);
        /*
        Cv2.Rectangle(leftImg, minLoc, new Point(minLoc.X + template.Cols, minLoc.Y + template.Rows), new Scalar(0, 255, 0), 2, LineTypes.Link8, 0);
        Cv2.ImWrite(Application.persistentDataPath + "/match.png", leftImg);
        */
        return new Point(minLoc.X + template.Cols / 2, minLoc.Y + template.Rows / 2); // center point of matcing rectangle
    }

    private void matchRightImageByEliline(Point p)
    {
        // parameter 'p': the center point of matching rectangle in left-image
        float height = p.Y;
        Vec3f eliline = new Vec3f(0, 1, -1 * height); // express by (a,b,c). ax + by + c = 0, which is eliline

        float topHeight = height - (template.Cols / 2);
        //Cv2.ComputeCorrespondEpilines
    }

    private void countParallax()
    {
        
    }

    public void setLeftImage(Mat image)
    {
        leftImg = image;
    }

    public void setRightImage(Mat image)
    {
        rightImg = image;
    }

}
